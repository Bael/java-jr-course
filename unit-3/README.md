# Unit 3 Cредства сборки и тестирования. Практическое задание.


## Предварительные требования
### Знакомство с Git

* Для незнакомых с гитом предложение пройти либо курс:
[курс по GIT](https://ru.hexlet.io/courses/intro_to_git)
     
     Или
* Прочитать первые две главы книги:
[Pro Git] (https://git-scm.com/book/ru/v2)

### Интегрированная среда разработки (IDE)
Начинаем работать в среде разработки. 
Пожалуйста, скачайте Intelli idea community edition

[Ссылка на скачивание](https://www.jetbrains.com/idea/download/)


## Практическая задача. Герой РПГ.

Отвлечемся на время от финансовых и аналитических задач, мы будем делать классы героев RPG.
Есть абстрактный воин который может атаковать и защищаться, у него есть показатели атаки и защиты а также уровень.

### Задача
Наша задача создать его подклассы со своими особенностями. Покрыть их тестами.
Список требуемых подклассов:

* Рыцарь - особенность, наносит черному рыцарю урон с удвоенной силой.
* Варвар - при здоровье ниже или равном 20% от максимума наносит удар с силой * 5.
* Черный рыцарь - пока без особенностей.

### Как расчитывается урон от атаки?

Формула удара:
- Высчитываем урон атаки. Атака = уровень атаки бойца + его сила. Также дополнительным параметром является критический удар. 
Критический удар включается если вероятность критического удара + уровень бойца  > порог критического удара.
- Рассчитываем поглощаемый урон, уровень защиты - урон атаки. Урон атаки утраивается или удар критический.

### Варианты выполнения задания?

Есть 3 варианта выполнения задания от сложного к простому:

Предварительно нужно выкачать репозиторий командой git clone 
 
* Переключаетесь в ветку **unit-3-var-1**. В данной ветке часть классов\ кода убрана. И вам нужно спроектировать все по своему.
Уже написанные тесты должны прходить.

* Переключаетесь в ветку **unit-3-var-2**. В данной ветке часть кода отвечающего за урон убрана. Вам нужно его написать. 
Уже написанные тесты должны прходить. Вы можете добавить новые тесты.

* Самый простой вариант. Работаете в ветке master (по умолчанию). Смотрите код, 
запускаете тесты. Думаете как можно было написать по другому.
Для усложнения можете - реализовать неполучение черным рыцарем критического удара ***никогда***. Написать на это тест.

## Что нужно для выполнения задания?
1) Знание ооп, то что мы проходили в прошлые занятия
2) Небольшое знание Gradle
3) Знание юнит тестирования

### Gradle. Система сборки.
Что такое системы сборки проекта и зачем они нужны?

Cистема управления сборкой, нужна чтобы через файл сборки - build.gradle настроить все необходимое для работы проекта.
Вы указываете все нужные зависимости\ библиотеки, и после этого через задачи сборки выполняете нужные действия.

Например, просмотр всех возможных действий что вы можете выполнить в проекте
(под линукс, под windows нужно указать название bat файла gradlew):

 **./gradlew tasks** 

Или, 

* Запуск тестов в проекте: ./gradlew test
* Запуск jvm приложения: ./gradlew run 
* Сборка проекта из запуск тестов : ./gradlew build
и многое другое   

Пока вам достаточно знать как запускать задачи градла. Если хотите углубиться то надо начать с краткого руководства 
по созданию первого проекта: 
* [Создание проекта с gradle](https://guides.gradle.org/building-java-applications/)
* [Подключение сторонней библиотеки в проект с Gradle](https://guides.gradle.org/consuming-jvm-libraries/)

### Unit тестирование. (иногда называют модульное тестирование).
Зачем вообще нужны юнит тесты?
* [Кратко о том зачем нужны](https://tproger.ru/translations/unit-tests-purposes/)
* [Еще один взгляд](https://ru.hexlet.io/blog/posts/how-to-test-code)

Есть хорошая статья о юнит тестах и том как их проектировать (английский): 

[unit-testing-java](http://web.mit.edu/6.005/www/fa16/classes/03-testing/)

Если вкратце то нужно думать о граничных значениях, там часто есть ошибки. 
Так же нужно учитывать ветки которые образуются на условиях, в идеале проходить их комбинации.

Юнит тестирование это целое искусство, но главное польза 
которую оно вам должно приносить думайте о тесте как о проверке контракта, 
спецификации которую должен исполнять ваш класс.
Т.е. тест должен помогать вам проектировать ваш код. Иначе пользы от него намного меньше. 
Тем более что тесты не бесплатные и занимают много усилий.


### Что нужно для написания своего теста?
Ситуацию рассматриваем в контексте проекта по нашему практическому заданию.  
#### Первый вопрос, как подключить библиотеку для тестирования?  
Ответ - в build gradle нужено в блоке зависимостей подключить библиотеку для тестирования.  
В нашем случае это будет JUnit. Пример  


// блок где мы запрашиваем нужные для работы зависимости (библиотеки)  
dependencies {  
    // Подключаем фреймворк тестирования JUnit версии 4.12  
    testImplementation 'junit:junit:4.12'  
}  

#### Второй вопрос, где находятся тесты? 
Первое что нам нужно помнить что пакет не равен директории где лежит файл класса.
Мы обсуждали это на прошлом занятии. Посмотрите на иерархию папок текущего проекта:


└── src  
    ├── main  
    │   ├── java  
    │   │   └── io  
    │   │       └── github  
    │   │           └── bael  
    │   │               └── javacourse  
    │   │                   └── knight  
    │   │                       ├── App.java  
    │   │                       ├── chances  
    │   │                       │   ├── BadLuckChance.java  
    │   │                       │   ├── Chance.java  
    │   │                       │   └── LuckyChance.java  
    │   │                       └── warriors  
    │   │                           ├── Actor.java  
    │   │                           ├── ActorState.java  
    │   │                           ├── Barbarian.java  
    │   │                           ├── BlackKnight.java  
    │   │                           ├── Damage.java  
    │   │                           ├── DamageRange.java  
    │   │                           ├── Knight.java  
    │   │                           ├── Warrior.java  
    │   │                           └── WarriorState.java  
    │   └── resources  
    └── test  
        ├── java  
        │   └── io  
        │       └── github  
        │           └── bael  
        │               └── javacourse  
        │                   └── knight  
        │                       ├── BarbarianTest.java  
        │                       ├── BlackKnightTest.java  
        │                       ├── KnightTest.java  
        │                       └── WarriorStateTest.java  
        └── resources  


Как мы видим в папке src содержится две папки - main и test, исходный код приложения содержится в папке main, а в папке test как и должно содержатся тесты. При этом директории класса и теста для данного класса совпадают, как и пакеты.
  
 За счет этого в классе теста вы можете использовать все что доступно по модификаторам доступа protected и default (который никак не указывается)

#### Третий вопрос. Как создать новый класс тестов?  

Чтобы создать автоматически новый тест для какого либо класса, нужно в студии Intelli Idea, 
находясь в тестируемом классе перевести курсор на название класса, нажать **ctrl + shift + t** и сгенерировать новый класс.  
 Заметьте что он создастся в том же пакете что и тестируемый класс. Но в другой директории (test).  
 Либо вы можете руками создать всю цепочку директорий и класс теста, указав в нем тот же пакет что у исходного класса что вы хотите проверить.

#### Четвертый вопрос. Как создать тестовый метод и проверить что нибудь?
* Для того чтобы ваш метод считался тестовым и запускался в ходе тестирования нужно пометить его аннотацией **@Test**
* Тестируем небольшой кусок функционала содержащий логику
* Обычно придерживаемся жизненного цикла   
   1) подготовка данных 
   2) влияние на них 
   3) проверка что данные корректны.  
     
Пример:
```java
@Test
    /**
     * Мы должны проверить что рыцарь не теряет здоровья, если его защита равна наносиму урону
     */
    public void testSolidDefence() {
        // подготавливаем данные для теста
        WarriorState blackKnightState = WarriorState.builder().attackLevel(100)
                .defenceLevel(300).hp(1000).maxHP(1000).strength(100).level(1).build();

        WarriorState whiteKnightState = WarriorState.builder().attackLevel(100)
                .defenceLevel(100).hp(1000).maxHP(1000).strength(100).level(1).build();

        Knight knight = new Knight(whiteKnightState);
        BlackKnight blackKnight = new BlackKnight(blackKnightState);

        BadLuckChance chance = new BadLuckChance();

        // совершаем действия которые мы хотим проверить
        knight.attackEnemy(chance, blackKnight);

        // проверяем что код выполняет условия спецификации\ теста 
        Assert.assertEquals(1000, blackKnight.getState().getHP());


    }

```


Тема тестирования намного глубже, поэтому мы будем к ней возвращаться снова и снова.   
Пока нужно просто приступить к практике.

#### Дальнейшая информация о юнит тестировании

* [анти паттерны тестирования](https://habr.com/ru/post/43761/)
* [анти паттерны тестирования (речь про виды тестирования)](https://habr.com/ru/post/358178/)
* [простейшие тесты с junit](http://javastudy.ru/junit/junit-hello-world/)
 